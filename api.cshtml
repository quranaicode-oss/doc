@using System
@using System.Collections.Generic
@using System.Data
@using System.IO
@using System.Linq
@using System.Globalization
@using System.Web
@using System.Text
@using System.Text.RegularExpressions
@using Newtonsoft.Json
@using DocumentFormat.OpenXml
@using DocumentFormat.OpenXml.Packaging
@using Wp = DocumentFormat.OpenXml.Wordprocessing
@using A = DocumentFormat.OpenXml.Drawing
@using Mas.com.eg.Models
@using Spire.Doc

@functions {
    public static Newtonsoft.Json.Linq.JObject ConvertElementToJson(OpenXmlElement element)
    {
        if (element == null) return null;
        var jsonObj = new Newtonsoft.Json.Linq.JObject();
        jsonObj["ElementType"] = element.GetType().Name;
        var attributes = new Newtonsoft.Json.Linq.JObject();
        foreach (var attr in element.GetAttributes())
        {
            attributes[attr.LocalName] = attr.Value;
        }
        if (attributes.HasValues)
        {
            jsonObj["Attributes"] = attributes;
        }
        if (!element.HasChildren && !string.IsNullOrEmpty(element.InnerText))
        {
            jsonObj["InnerText"] = element.InnerText;
        }
        if (element.HasChildren)
        {
            var childrenArray = new Newtonsoft.Json.Linq.JArray();
            foreach (var child in element.ChildElements)
            {
                childrenArray.Add(ConvertElementToJson(child));
            }
            jsonObj["Children"] = childrenArray;
        }
        return jsonObj;
    }

    public class DocumentConverter
{
    public class NewDoc
    {
        public bool success { get; set; }
        public string message { get; set; }
        public byte[] fileBytes { get; set; }
    }

    public class JsonPayload
    {
        public string Direction { get; set; }
        public List<object> Elements { get; set; }
        public string FileVersionPath { get; set; }
        public int Version { get; set; }
    }

    public class JsonParagraph { public int ID { get; set; } public string Type { get; set; } = "Paragraph"; public string StructureKey { get; set; } public List<object> Content { get; set; } = new List<object>(); public Dictionary<string, object> Formatting { get; set; } = new Dictionary<string, object>(); }
    public class JsonRun { public string Text { get; set; } public Dictionary<string, bool> Formatting { get; set; } = new Dictionary<string, bool>(); public Dictionary<string, string> FormattingValues { get; set; } = new Dictionary<string, string>(); }
    public class JsonCheckbox { public string Type { get; set; } = "Checkbox"; public bool IsChecked { get; set; } public string Content { get; set; } }
    public class JsonTable { public int ID { get; set; } public string Type { get; set; } = "Table"; public string StructureKey { get; set; } public List<JsonTableRow> Content { get; set; } = new List<JsonTableRow>(); public Dictionary<string, string> Borders { get; set; } = new Dictionary<string, string>(); public List<double?> ColumnWidths { get; set; } = new List<double?>(); }
    public class JsonTableRow { public List<JsonTableCell> Cells { get; set; } = new List<JsonTableCell>(); public Dictionary<string, string> Borders { get; set; } = new Dictionary<string, string>(); }
    public class JsonTableCell { public string Content { get; set; } public int GridSpan { get; set; } = 1; public string VerticalMerge { get; set; } public List<JsonRun> FormattedRuns { get; set; } = new List<JsonRun>(); public List<JsonCheckbox> Checkboxes { get; set; } = new List<JsonCheckbox>(); public Dictionary<string, string> Borders { get; set; } = new Dictionary<string, string>(); public int? rowSpan { get; set; } public string Direction { get; set; } public string Alignment { get; set; } public string TextRotation { get; set; } public string algin { get => Alignment; set => Alignment = value; }}
    public class JsonImage { public int ID { get; set; } public string Type { get; set; } = "Image"; public string StructureKey { get; set; } public string Content { get; set; } }
public static readonly Regex VersionPattern = new Regex(@"^(.+?)(?:\s*\(Rev\s?(\d+)\))?$", RegexOptions.IgnoreCase);
          public static string GetVersionedPath(string basePath, int? version)
        {
            var directory = Path.GetDirectoryName(basePath);
            var baseFileNameWithoutExt = Path.GetFileNameWithoutExtension(basePath);
            var extension = Path.GetExtension(basePath);

            // If a specific version is requested, build the path for it.
            if (version.HasValue)
            {
                if (version.Value == 0) return basePath; // Version 0 is the base file itself.
                string specificPath = Path.Combine(directory, $"{baseFileNameWithoutExt}_v({version.Value}){extension}");
                return File.Exists(specificPath) ? specificPath : basePath; // Fallback to base if not found
            }

            // If no version is specified, find the latest version.
            if (!Directory.Exists(directory)) return basePath;

            var files = Directory.GetFiles(directory, $"{baseFileNameWithoutExt}*{extension}");
            int latestVersion = -1;
            string latestFile = basePath;

            foreach (var file in files)
            {
                var currentFileName = Path.GetFileNameWithoutExtension(file);
                var match = VersionPattern.Match(currentFileName);

                if (match.Success && match.Groups[1].Value.Equals(baseFileNameWithoutExt, StringComparison.OrdinalIgnoreCase))
                {
                    int currentVersion = 0; // Default to 0 for the base file
                    if (match.Groups[2].Success && int.TryParse(match.Groups[2].Value, out int parsedVersion))
                    {
                        currentVersion = parsedVersion;
                    }

                    if (currentVersion > latestVersion)
                    {
                        latestVersion = currentVersion;
                        latestFile = file;
                    }
                    // Handle the base file itself if it's the only one
                    else if (latestVersion == -1 && currentVersion == 0)
                    {
                        latestVersion = 0;
                        latestFile = file;
                    }
                }
            }
            return latestFile;
        }

        // ** REVISED: Generates the next available version number for a new upload **
       public static string GenerateNewVersionFileName(string originalPath)
{
    var directory = Path.GetDirectoryName(originalPath);
    var fileNameWithoutExt = Path.GetFileNameWithoutExtension(originalPath);
    var extension = Path.GetExtension(originalPath);

    var match = VersionPattern.Match(fileNameWithoutExt);
    string baseName = match.Success ? match.Groups[1].Value.Trim() : fileNameWithoutExt;

    var files = Directory.GetFiles(directory, $"{baseName}*{extension}");
    int maxVersion = 0;
    foreach (var file in files)
    {
        var currentMatch = VersionPattern.Match(Path.GetFileNameWithoutExtension(file));
        if (currentMatch.Success && currentMatch.Groups[1].Value.Trim().Equals(baseName, StringComparison.OrdinalIgnoreCase))
        {
            if (currentMatch.Groups[2].Success && int.TryParse(currentMatch.Groups[2].Value, out int currentVersion))
            {
                if (currentVersion > maxVersion)
                {
                    maxVersion = currentVersion;
                }
            }
        }
    }

    int nextVersion = maxVersion + 1;
    // Format number with two digits (e.g., 4 becomes 04)
    return Path.Combine(directory, $"{baseName} (Rev {nextVersion:D2}){extension}");
}
    public static string FindLatestVersion(string filePath)
    {
        try
        {
            var directory = Path.GetDirectoryName(filePath);
            var fileName = Path.GetFileName(filePath);
            var extension = Path.GetExtension(filePath);

            if (!Directory.Exists(directory) || !File.Exists(filePath))
                return filePath;

            var baseFileNameWithoutExt = Path.GetFileNameWithoutExtension(filePath);
            var files = Directory.GetFiles(directory, $"*{extension}");

            var versionPattern = new Regex(@"^(.+?)(?:_v\((\d+)\))?(?:_S\((\d+)\))?$", RegexOptions.IgnoreCase);
            var baseMatch = versionPattern.Match(baseFileNameWithoutExt);

            if (!baseMatch.Success) return filePath;

            string baseCodeAndName = baseMatch.Groups[1].Value;
            int latestVersion = -1;
            string latestFile = filePath;

            foreach (var file in files)
            {
                var currentFileName = Path.GetFileNameWithoutExtension(file);
                var currentMatch = versionPattern.Match(currentFileName);

                if (currentMatch.Success && currentMatch.Groups[1].Value.Equals(baseCodeAndName, StringComparison.OrdinalIgnoreCase))
                {
                    int currentVersion = 0;
                    if (currentMatch.Groups[2].Success)
                    {
                        int.TryParse(currentMatch.Groups[2].Value, out currentVersion);
                    }

                    if (currentVersion > latestVersion)
                    {
                        latestVersion = currentVersion;
                        latestFile = file;
                    }
                }
            }

            return File.Exists(latestFile) ? latestFile : filePath;
        }
        catch
        {
            return filePath;
        }
    }
public static NewDoc ConvertJsonToDocx(string jsonInput, string appPath, string recordID)
{
    try
    {
        JsonPayload payload = JsonConvert.DeserializeObject<JsonPayload>(jsonInput);
        if (payload == null || string.IsNullOrEmpty(payload.FileVersionPath))
        {
            return new NewDoc { success = false, message = "File version path was not found in the JSON payload." };
        }

        string templatePath = Path.Combine(appPath, payload.FileVersionPath.TrimStart('\\', '/').Replace('/', '\\'));
        if (!File.Exists(templatePath))
        {
            return new NewDoc { success = false, message = $"Template file not found: {templatePath}" };
        }

        byte[] originalBytes = File.ReadAllBytes(templatePath);
        using (MemoryStream memStream = new MemoryStream())
        {
            memStream.Write(originalBytes, 0, originalBytes.Length);
            memStream.Position = 0;

            using (WordprocessingDocument wordDoc = WordprocessingDocument.Open(memStream, true))
            {
                var body = wordDoc.MainDocumentPart.Document.Body;

                var structuredElements = CollectStructuredDocElements(body);
                var consumed = new HashSet<int>();

                foreach (var element in payload.Elements ?? new List<object>())
                {
                    var jObject = element as Newtonsoft.Json.Linq.JObject ?? Newtonsoft.Json.Linq.JObject.FromObject(element);
                    if (jObject == null) continue;

                    string elementType = jObject["Type"]?.ToString();
                    if (string.IsNullOrEmpty(elementType)) continue;

                    string structureKey = jObject["StructureKey"]?.ToString();
                    StructuredDocElement match = null;

                    if (!string.IsNullOrEmpty(structureKey))
                    {
                        match = structuredElements.FirstOrDefault(se => !consumed.Contains(se.Index) &&
                                                                         se.Type == elementType &&
                                                                         string.Equals(se.StructureKey, structureKey, StringComparison.Ordinal));
                    }

                    if (match == null)
                    {
                        match = structuredElements.FirstOrDefault(se => !consumed.Contains(se.Index) && se.Type == elementType);
                    }

                    if (match == null) continue;

                    consumed.Add(match.Index);

                    if (elementType == "Paragraph" && match.Element is Wp.Paragraph paragraph)
                    {
                        var jsonPara = jObject.ToObject<JsonParagraph>();
                        InjectTextToParagraphSafe(paragraph, jsonPara);
                    }
                    else if (elementType == "Table" && match.Element is Wp.Table table)
                    {
                        var jsonTable = jObject.ToObject<JsonTable>();
                        InjectTextToTableSafe(table, jsonTable);
                    }
                }

                if (!string.IsNullOrEmpty(recordID))
                {
                    AddFooter(body, recordID);
                }

                wordDoc.Save();
            }

            return new NewDoc { success = true, fileBytes = memStream.ToArray() };
        }
    }
    catch (Exception ex)
    {
        return new NewDoc { success = false, message = $"Error processing file: {ex.Message}" };
    }
}
    public static string GenerateNewVersionFileName(string originalPath, int? serialNumber = null)
    {
        var directory = Path.GetDirectoryName(originalPath);
        var fileName = Path.GetFileNameWithoutExtension(originalPath);
        var extension = Path.GetExtension(originalPath);

        var versionPattern = new Regex(@"^(.+?)(?:_v\((\d+)\))?(?:_S\((\d+)\))?$", RegexOptions.IgnoreCase);
        var match = versionPattern.Match(fileName);

        string baseCodeAndName = match.Success ? match.Groups[1].Value : fileName;

        var files = Directory.GetFiles(directory, $"{baseCodeAndName}*{extension}");
        int nextVersion = 1;

        foreach (var file in files)
        {
            var currentFileName = Path.GetFileNameWithoutExtension(file);
            var currentMatch = versionPattern.Match(currentFileName);

            if (currentMatch.Success && currentMatch.Groups[1].Value.Equals(baseCodeAndName, StringComparison.OrdinalIgnoreCase))
            {
                if (currentMatch.Groups[2].Success)
                {
                    if (int.TryParse(currentMatch.Groups[2].Value, out int currentVersion))
                    {
                        nextVersion = Math.Max(nextVersion, currentVersion + 1);
                    }
                }
            }
        }

        string newFileName = $"{baseCodeAndName}_v({nextVersion})";
        if (serialNumber.HasValue)
        {
            newFileName += $"_S({serialNumber.Value})";
        }

        return Path.Combine(directory, newFileName + extension);
    }
public static object ConvertDocxToJson(string filePath, int? version)
{
    try
    {
        string pathToRead = GetVersionedPath(filePath, version);
        if (!File.Exists(pathToRead))
        {
            return new { success = false, message = $"Template file not found: {pathToRead}" };
        }

        var finalMatch = VersionPattern.Match(Path.GetFileNameWithoutExtension(pathToRead));
        int finalVersion = 0;
        if (finalMatch.Success && finalMatch.Groups[2].Success)
        {
            int.TryParse(finalMatch.Groups[2].Value, out finalVersion);
        }

        var documentElements = new List<object>();
        string documentDirection = "ltr";
        int elementIdCounter = 0;

        using (WordprocessingDocument wordDoc = WordprocessingDocument.Open(pathToRead, false))
        {
            var mainPart = wordDoc.MainDocumentPart;
            var body = mainPart.Document.Body;
            var defaultDirection = DetectDocumentDefaultDirection(mainPart);
            documentDirection = DetermineDocumentDirection(wordDoc, defaultDirection);

            // Call the new recursive parsing function starting from the body
            ParseElementsRecursive(body.ChildElements, ref elementIdCounter, mainPart, documentElements, documentDirection);
        }

        string versionPathForClient = pathToRead.Replace(HttpRuntime.AppDomainAppPath, "").Replace('\\', '/');
        return new { success = true, json = new JsonPayload { Elements = documentElements, Direction = documentDirection, FileVersionPath = versionPathForClient, Version = finalVersion } };
    }
    catch (Exception ex)
    {
        return new { success = false, message = $"Error reading file: {ex.Message}" };
    }
}

// New helper function to parse elements recursively
private class StructuredDocElement
{
    public OpenXmlElement Element { get; set; }
    public string Type { get; set; }
    public string StructureKey { get; set; }
    public int Index { get; set; }
}

private static List<StructuredDocElement> CollectStructuredDocElements(Wp.Body body)
{
    var collected = new List<StructuredDocElement>();
    int structuralIndex = 0;
    CollectStructuredDocElementsRecursive(body?.ChildElements, string.Empty, collected, ref structuralIndex);
    return collected;
}

private static void CollectStructuredDocElementsRecursive(IEnumerable<OpenXmlElement> elements, string path, List<StructuredDocElement> collector, ref int structuralIndex)
{
    if (elements == null) return;
    int localIndex = 0;
    foreach (var element in elements)
    {
        string childPath = string.IsNullOrEmpty(path) ? localIndex.ToString() : $"{path}.{localIndex}";

        if (element is Wp.Paragraph paragraph)
        {
            collector.Add(new StructuredDocElement { Element = paragraph, Type = "Paragraph", StructureKey = childPath, Index = structuralIndex++ });
        }
        else if (element is Wp.Table table)
        {
            collector.Add(new StructuredDocElement { Element = table, Type = "Table", StructureKey = childPath, Index = structuralIndex++ });
        }
        else if (element is Wp.SdtBlock sdtBlock)
        {
            CollectStructuredDocElementsRecursive(sdtBlock?.SdtContentBlock?.ChildElements, childPath, collector, ref structuralIndex);
            localIndex++;
            continue;
        }

        localIndex++;
    }
}

private static void ParseElementsRecursive(IEnumerable<OpenXmlElement> elements, ref int elementIdCounter, MainDocumentPart mainPart, List<object> documentElements, string fallbackDirection, string path = "")
{
    if (elements == null) return;
    int index = 0;
    foreach (var element in elements)
    {
        string currentKey = string.IsNullOrEmpty(path) ? index.ToString() : $"{path}.{index}";
        elementIdCounter++;
        if (element is Wp.Paragraph para)
        {
            documentElements.Add(ParseParagraph(para, elementIdCounter, mainPart, currentKey, fallbackDirection));
        }
        else if (element is Wp.Table table)
        {
            documentElements.Add(ParseTable(table, elementIdCounter, mainPart, currentKey, fallbackDirection));
        }
        else if (element is Wp.SdtBlock sdtBlock)
        {
            // If it's a Content Control block, parse the elements INSIDE it
            var content = sdtBlock.SdtContentBlock;
            if (content != null)
            {
                ParseElementsRecursive(content.ChildElements, ref elementIdCounter, mainPart, documentElements, fallbackDirection, currentKey);
                index++;
                continue;
            }
        }
        else if (element.Descendants<Wp.Drawing>().Any())
        {
            documentElements.AddRange(ParseImages(element, elementIdCounter, mainPart, currentKey));
        }
        // Other elements are ignored to keep the JSON clean
        index++;
    }
}




    private static string FindOriginalFile(string versionedPath)
    {
        try
        {
            var directory = Path.GetDirectoryName(versionedPath);
            var fileName = Path.GetFileNameWithoutExtension(versionedPath);
            var extension = Path.GetExtension(versionedPath);

            var versionPattern = new Regex(@"^(.+?)(?:_v\(\d+\))?(?:_S\(\d+\))?$");
            var match = versionPattern.Match(fileName);

            if (match.Success)
            {
                string baseName = match.Groups[1].Value;
                string originalPath = Path.Combine(directory, baseName + extension);
                if (File.Exists(originalPath))
                {
                    return originalPath;
                }
            }

            return versionedPath;
        }
        catch
        {
            return versionedPath;
        }
    }
    private static Wp.JustificationValues? MapAlignmentToJustification(string alignment)
    {
        if (string.IsNullOrWhiteSpace(alignment)) return null;

        var normalized = alignment.Trim().ToLowerInvariant();
        switch (normalized)
        {
            case "left":
                return Wp.JustificationValues.Left;
            case "right":
                return Wp.JustificationValues.Right;
            case "center":
                return Wp.JustificationValues.Center;
            case "justify":
            case "both":
                return Wp.JustificationValues.Both;
            case "distribute":
                return Wp.JustificationValues.Distribute;
            case "start":
                return Wp.JustificationValues.Start;
            case "end":
                return Wp.JustificationValues.End;
            default:
                if (Enum.TryParse(normalized, true, out Wp.JustificationValues parsed))
                {
                    return parsed;
                }
                return null;
        }
    }

    private static void InjectTextToParagraphSafe(Wp.Paragraph para, JsonParagraph jsonPara)
{
    if (para == null || jsonPara == null) return;

    try
    {
        var pPr = para.ParagraphProperties;
        if (pPr == null)
        {
            pPr = new Wp.ParagraphProperties();
            para.PrependChild(pPr);
        }

        var existingRunTemplates = para.Elements<Wp.Run>()
            .Select(r => r.RunProperties != null ? (Wp.RunProperties)r.RunProperties.CloneNode(true) : null)
            .ToList();

        object dirValue = null;
        if (jsonPara.Formatting != null)
        {
            jsonPara.Formatting.TryGetValue("Direction", out dirValue);
            if (dirValue == null)
            {
                jsonPara.Formatting.TryGetValue("direction", out dirValue);
            }
        }

        var normalizedDirection = NormalizeDirectionToken(dirValue?.ToString());
        if (!string.IsNullOrEmpty(normalizedDirection))
        {
            if (normalizedDirection == "rtl")
            {
                if (pPr.BiDi == null) pPr.Append(new Wp.BiDi());
            }
            else if (normalizedDirection == "ltr" || normalizedDirection == "inherit")
            {
                pPr.BiDi?.Remove();
            }
        }

        object alignValue = null;
        if (jsonPara.Formatting != null)
        {
            jsonPara.Formatting.TryGetValue("Alignment", out alignValue);
            if (alignValue == null)
            {
                jsonPara.Formatting.TryGetValue("algin", out alignValue);
            }
        }

        if (alignValue != null)
        {
            var targetValue = MapAlignmentToJustification(alignValue.ToString());
            if (targetValue.HasValue)
            {
                var alignment = pPr.Justification;
                if (alignment == null)
                {
                    alignment = new Wp.Justification();
                    pPr.Append(alignment);
                }
                alignment.Val = targetValue.Value;
            }
        }

        if (jsonPara.Content == null || !jsonPara.Content.Any())
        {
            return;
        }

        var extractedRuns = new List<JsonRun>();
        foreach (var contentItem in jsonPara.Content)
        {
            if (contentItem == null) continue;

            if (contentItem is JsonRun directRun)
            {
                extractedRuns.Add(directRun);
                continue;
            }

            try
            {
                var token = contentItem as Newtonsoft.Json.Linq.JToken ?? Newtonsoft.Json.Linq.JToken.FromObject(contentItem);
                if (token == null) continue;

                if (token["Type"] != null && token["Type"].ToString() == "Checkbox")
                {
                    // Skip checkbox placeholder replacement; keep original checkbox element intact.
                    continue;
                }

                var parsedRun = token.ToObject<JsonRun>();
                if (parsedRun != null)
                {
                    extractedRuns.Add(parsedRun);
                }
            }
            catch
            {
                // Ignore malformed content entries to avoid breaking document generation.
            }
        }

        if (!extractedRuns.Any())
        {
            string fallbackText = string.Join("", jsonPara.Content.Select(c =>
            {
                try
                {
                    var token = c as Newtonsoft.Json.Linq.JToken ?? Newtonsoft.Json.Linq.JToken.FromObject(c);
                    return token?["Text"]?.ToString() ?? string.Empty;
                }
                catch
                {
                    return string.Empty;
                }
            }));

            fallbackText = System.Web.HttpUtility.HtmlDecode(fallbackText ?? string.Empty);
            if (string.IsNullOrEmpty(fallbackText)) return;

            para.RemoveAllChildren<Wp.Run>();
            var fallbackRun = new Wp.Run();
            var fallbackRunProps = ResolveRunProperties(existingRunTemplates, 0, null);
            if (fallbackRunProps != null)
            {
                fallbackRun.RunProperties = fallbackRunProps;
            }
            var text = new Wp.Text(fallbackText) { Space = SpaceProcessingModeValues.Preserve };
            fallbackRun.Append(text);
            para.AppendChild(fallbackRun);
            return;
        }

        var combinedText = string.Concat(extractedRuns.Select(r => r?.Text ?? string.Empty));
        if (combinedText == para.InnerText)
        {
            return;
        }

        para.RemoveAllChildren<Wp.Run>();

        int runIndex = 0;
        foreach (var runData in extractedRuns)
        {
            if (runData == null) continue;

            string decodedText = System.Web.HttpUtility.HtmlDecode(runData.Text ?? string.Empty) ?? string.Empty;

            var run = new Wp.Run();
            var runProperties = BuildRunProperties(runData);
            var resolvedProperties = ResolveRunProperties(existingRunTemplates, runIndex, runProperties);
            if (resolvedProperties != null)
            {
                run.RunProperties = resolvedProperties;
            }

            var normalizedText = decodedText.Replace("\r\n", "\n");
            var parts = normalizedText.Split(new[] { "\n" }, StringSplitOptions.None);
            for (int i = 0; i < parts.Length; i++)
            {
                run.AppendChild(new Wp.Text(parts[i]) { Space = SpaceProcessingModeValues.Preserve });
                if (i < parts.Length - 1)
                {
                    run.AppendChild(new Wp.Break());
                }
            }

            para.AppendChild(run);
            runIndex++;
        }
    }
    catch (Exception)
    {
    }
}

private static Wp.RunProperties BuildRunProperties(JsonRun runData)
{
    if (runData == null) return null;

    Wp.RunProperties runProperties = null;

    if (runData.Formatting != null)
    {
        if (TryGetBoolean(runData.Formatting, "Bold"))
        {
            if (runProperties == null) runProperties = new Wp.RunProperties();
            runProperties.AppendChild(new Wp.Bold());
        }
        if (TryGetBoolean(runData.Formatting, "Italic"))
        {
            if (runProperties == null) runProperties = new Wp.RunProperties();
            runProperties.AppendChild(new Wp.Italic());
        }
        if (TryGetBoolean(runData.Formatting, "Underline"))
        {
            if (runProperties == null) runProperties = new Wp.RunProperties();
            var underline = new Wp.Underline();
            if (runData.FormattingValues != null && runData.FormattingValues.TryGetValue("UnderlineStyle", out string underlineStyle) &&
                Enum.TryParse(underlineStyle, true, out Wp.UnderlineValues underlineValue))
            {
                underline.Val = underlineValue;
            }
            else
            {
                underline.Val = Wp.UnderlineValues.Single;
            }
            runProperties.AppendChild(underline);
        }
    }

    if (runData.FormattingValues != null)
    {
        if (runData.FormattingValues.TryGetValue("ColorValue", out string colorValue) && !string.IsNullOrWhiteSpace(colorValue))
        {
            if (runProperties == null) runProperties = new Wp.RunProperties();
            runProperties.AppendChild(new Wp.Color { Val = colorValue });
        }
        if (runData.FormattingValues.TryGetValue("HighlightValue", out string highlightValue) && !string.IsNullOrWhiteSpace(highlightValue))
        {
            if (runProperties == null) runProperties = new Wp.RunProperties();
            if (Enum.TryParse(highlightValue, true, out Wp.HighlightColorValues highlightEnum))
            {
                runProperties.AppendChild(new Wp.Highlight { Val = highlightEnum });
            }
            else
            {
                runProperties.AppendChild(new Wp.Highlight { Val = Wp.HighlightColorValues.Yellow });
            }
        }
        if (runData.FormattingValues.TryGetValue("ShadingValue", out string shadingValue) && !string.IsNullOrWhiteSpace(shadingValue))
        {
            if (runProperties == null) runProperties = new Wp.RunProperties();
            runProperties.AppendChild(new Wp.Shading { Fill = shadingValue, Val = Wp.ShadingPatternValues.Clear });
        }
        if (runData.FormattingValues.TryGetValue("FontSize", out string fontSize) && !string.IsNullOrWhiteSpace(fontSize))
        {
            if (runProperties == null) runProperties = new Wp.RunProperties();
            runProperties.AppendChild(new Wp.FontSize { Val = fontSize });
        }
        if (runData.FormattingValues.TryGetValue("FontFamily", out string fontFamily) && !string.IsNullOrWhiteSpace(fontFamily))
        {
            if (runProperties == null) runProperties = new Wp.RunProperties();
            runProperties.AppendChild(new Wp.RunFonts { Ascii = fontFamily, HighAnsi = fontFamily, ComplexScript = fontFamily });
        }
    }

    return runProperties;
}

private static bool TryGetBoolean(Dictionary<string, bool> dictionary, string key)
{
    if (dictionary == null) return false;
    if (dictionary.TryGetValue(key, out bool value))
    {
        return value;
    }
    return false;
}
private static void InjectTextToTableSafe(Wp.Table table, JsonTable jsonTable)
{
    if (table == null || jsonTable?.Content == null) return;

    try
    {
        var rows = table.Elements<Wp.TableRow>().ToList();
        for (int rowIndex = 0; rowIndex < Math.Min(rows.Count, jsonTable.Content.Count); rowIndex++)
        {
            var docxRow = rows[rowIndex];
            var jsonRow = jsonTable.Content[rowIndex];
            var cells = docxRow.Elements<Wp.TableCell>().ToList();

            for (int cellIndex = 0; cellIndex < Math.Min(cells.Count, jsonRow.Cells.Count); cellIndex++)
            {
                var docxCell = cells[cellIndex];
                var jsonCell = jsonRow.Cells[cellIndex];

                if (docxCell.TableCellProperties?.VerticalMerge?.Val?.Value == Wp.MergedCellValues.Continue)
                {
                    continue;
                }

                bool hasFormattedRuns = jsonCell.FormattedRuns != null &&
                    jsonCell.FormattedRuns.Any(run => run != null && !string.IsNullOrEmpty(run.Text));
                bool hasPlainContent = !string.IsNullOrWhiteSpace(jsonCell.Content);

                if (!hasFormattedRuns && !hasPlainContent)
                {
                    continue;
                }

                var existingParagraphs = docxCell.Elements<Wp.Paragraph>().ToList();
                if (!existingParagraphs.Any())
                {
                    var newParagraph = new Wp.Paragraph();
                    docxCell.Append(newParagraph);
                    existingParagraphs.Add(newParagraph);
                }

                var paragraphPayloads = hasFormattedRuns
                    ? BuildParagraphPayloadFromRuns(jsonCell.FormattedRuns, existingParagraphs.Count)
                    : BuildParagraphPayloadFromPlainText(jsonCell.Content, existingParagraphs.Count);

                ApplyParagraphPayloadsToCell(docxCell, existingParagraphs, paragraphPayloads, jsonCell);
            }
        }
    }
    catch (Exception)
    {
    }
}

private static void ApplyParagraphPayloadsToCell(Wp.TableCell docxCell, List<Wp.Paragraph> existingParagraphs,
    List<List<JsonRun>> paragraphPayloads, JsonTableCell jsonCell)
{
    if (docxCell == null || paragraphPayloads == null || paragraphPayloads.Count == 0)
    {
        return;
    }

    while (existingParagraphs.Count < paragraphPayloads.Count)
    {
        var cloned = CloneParagraphWithProperties(existingParagraphs.LastOrDefault());
        docxCell.Append(cloned);
        existingParagraphs.Add(cloned);
    }

    for (int paragraphIndex = 0; paragraphIndex < paragraphPayloads.Count; paragraphIndex++)
    {
        var targetParagraph = existingParagraphs[paragraphIndex];
        var payloadRuns = paragraphPayloads[paragraphIndex] ?? new List<JsonRun>();

        var jsonParagraph = new JsonParagraph();
        if (jsonCell != null)
        {
            var cellDirection = NormalizeDirectionToken(jsonCell.Direction);
            if (!string.IsNullOrEmpty(cellDirection))
            {
                jsonParagraph.Formatting["Direction"] = cellDirection;
            }

            var cellAlignment = NormalizeAlignmentToken(jsonCell.Alignment);
            if (!string.IsNullOrEmpty(cellAlignment))
            {
                jsonParagraph.Formatting["Alignment"] = cellAlignment;
                jsonParagraph.Formatting["algin"] = cellAlignment;
            }
        }

        jsonParagraph.Content = payloadRuns.Cast<object>().ToList();
        InjectTextToParagraphSafe(targetParagraph, jsonParagraph);

        if (!payloadRuns.Any())
        {
            targetParagraph.RemoveAllChildren<Wp.Run>();
        }
    }

    for (int index = paragraphPayloads.Count; index < existingParagraphs.Count; index++)
    {
        existingParagraphs[index].RemoveAllChildren<Wp.Run>();
    }
}

private static List<List<JsonRun>> BuildParagraphPayloadFromRuns(List<JsonRun> runs, int existingParagraphCount)
{
    var payloads = new List<List<JsonRun>>();
    var current = new List<JsonRun>();

    if (runs != null)
    {
        foreach (var run in runs)
        {
            if (run == null)
            {
                continue;
            }

            if (IsParagraphSeparator(run))
            {
                payloads.Add(current);
                current = new List<JsonRun>();
                continue;
            }

            var runText = run.Text ?? string.Empty;
            var normalizedText = runText.Replace("\r\n", "\n").Replace("\r", "\n");

            if (normalizedText.Contains("\n"))
            {
                var segments = normalizedText.Split('\n');
                for (int i = 0; i < segments.Length; i++)
                {
                    current.Add(CloneRunWithText(run, segments[i]));

                    if (i < segments.Length - 1)
                    {
                        payloads.Add(current);
                        current = new List<JsonRun>();
                    }
                }

                continue;
            }

            current.Add(CloneRunWithText(run, runText));
        }
    }

    payloads.Add(current);

    if (!payloads.Any())
    {
        payloads.Add(new List<JsonRun>());
    }

    while (existingParagraphCount > payloads.Count)
    {
        payloads.Add(new List<JsonRun>());
    }

    return payloads;
}

private static List<List<JsonRun>> BuildParagraphPayloadFromPlainText(string content, int existingParagraphCount)
{
    var payloads = new List<List<JsonRun>>();
    var normalized = (content ?? string.Empty).Replace("\r\n", "\n");
    var segments = normalized.Split(new[] { "\n" }, StringSplitOptions.None);

    foreach (var segment in segments)
    {
        payloads.Add(new List<JsonRun> { new JsonRun { Text = segment } });
    }

    if (!payloads.Any())
    {
        payloads.Add(new List<JsonRun>());
    }

    while (existingParagraphCount > payloads.Count)
    {
        payloads.Add(new List<JsonRun>());
    }

    return payloads;
}

private static bool IsParagraphSeparator(JsonRun run)
{
    if (run == null || run.Text == null)
    {
        return false;
    }

    if (!string.Equals(run.Text, "\n", StringComparison.Ordinal))
    {
        return false;
    }

    bool hasFormatting = (run.Formatting != null && run.Formatting.Any()) ||
                         (run.FormattingValues != null && run.FormattingValues.Any());
    return !hasFormatting;
}

private static JsonRun CloneRunWithText(JsonRun source, string text)
{
    if (source == null)
    {
        return new JsonRun { Text = text };
    }

    return new JsonRun
    {
        Text = text,
        Formatting = source.Formatting != null
            ? new Dictionary<string, bool>(source.Formatting)
            : new Dictionary<string, bool>(),
        FormattingValues = source.FormattingValues != null
            ? new Dictionary<string, string>(source.FormattingValues)
            : new Dictionary<string, string>()
    };
}

private static Wp.Paragraph CloneParagraphWithProperties(Wp.Paragraph referenceParagraph)
{
    var newParagraph = new Wp.Paragraph();
    if (referenceParagraph?.ParagraphProperties != null)
    {
        newParagraph.ParagraphProperties = (Wp.ParagraphProperties)referenceParagraph.ParagraphProperties.CloneNode(true);
    }

    var referenceRuns = referenceParagraph?.Elements<Wp.Run>().ToList();
    if (referenceRuns != null && referenceRuns.Count > 0)
    {
        foreach (var refRun in referenceRuns)
        {
            var newRun = new Wp.Run();
            if (refRun.RunProperties != null)
            {
                newRun.RunProperties = (Wp.RunProperties)refRun.RunProperties.CloneNode(true);
            }
            newParagraph.AppendChild(newRun);
        }
    }

    return newParagraph;
}

private static Wp.RunProperties ResolveRunProperties(List<Wp.RunProperties> templates, int runIndex, Wp.RunProperties explicitProperties)
{
    if (explicitProperties != null)
    {
        return explicitProperties;
    }

    if (templates == null || templates.Count == 0)
    {
        return null;
    }

    if (runIndex < templates.Count && templates[runIndex] != null)
    {
        return (Wp.RunProperties)templates[runIndex].CloneNode(true);
    }

    foreach (var template in templates)
    {
        if (template != null)
        {
            return (Wp.RunProperties)template.CloneNode(true);
        }
    }

    return null;
}
          
private static string NormalizeAlignmentToken(string alignment)
{
    if (string.IsNullOrWhiteSpace(alignment)) return null;

    var normalized = alignment.Trim().ToLowerInvariant();

    switch (normalized)
    {
        case "both":
        case "distribute":
            return "justify";
        case "center":
        case "justify":
        case "left":
        case "right":
        case "start":
        case "end":
            return normalized;
        case "inherit":
            return null;
        default:
            return normalized;
    }
}

private static string NormalizeDirectionToken(string direction)
{
    if (string.IsNullOrWhiteSpace(direction)) return null;

    var normalized = direction.Trim().ToLowerInvariant();
    switch (normalized)
    {
        case "rtl":
        case "ltr":
        case "inherit":
            return normalized;
        default:
            return null;
    }
}

private static bool IsPropertyEnabled(OpenXmlElement onOffElement)
{
    if (onOffElement is DocumentFormat.OpenXml.Wordprocessing.OnOffType onOff)
    {
        var val = onOff.Val;
        if (val == null)
        {
            return true;
        }

        if (val.HasValue)
        {
            return val.Value;
        }

        return true;
    }

    return onOffElement != null;
}

private static string DetectDocumentDefaultDirection(MainDocumentPart mainPart)
{
    if (mainPart == null) return "ltr";

    try
    {
        var stylesPart = mainPart.StyleDefinitionsPart;
        var docDefaults = stylesPart?.Styles?.DocDefaults?.ParagraphPropertiesDefault?
            .GetFirstChild<Wp.ParagraphProperties>();
        if (docDefaults != null)
        {
            if (IsPropertyEnabled(docDefaults.BiDi)) return "rtl";
            var defaultTextDir = docDefaults.GetFirstChild<Wp.TextDirection>()?.Val?.Value;
            if (IsRtlTextDirection(defaultTextDir)) return "rtl";
        }

        var body = mainPart.Document.Body;
        var sectionProps = body?.Elements<Wp.SectionProperties>().LastOrDefault();
        if (sectionProps != null)
        {
            var sectionBiDi = sectionProps.GetFirstChild<Wp.BiDi>();
            if (IsPropertyEnabled(sectionBiDi)) return "rtl";
            var sectionTextDir = sectionProps.GetFirstChild<Wp.TextDirection>()?.Val?.Value;
            if (IsRtlTextDirection(sectionTextDir)) return "rtl";
        }

        var settings = mainPart.DocumentSettingsPart?.Settings;
        var documentBiDi = settings?.GetFirstChild<Wp.BiDi>();
        if (IsPropertyEnabled(documentBiDi)) return "rtl";
    }
    catch
    {
    }

    return "ltr";
}

private static string DetermineDocumentDirection(WordprocessingDocument wordDoc, string defaultDirection)
{
    try
    {
        var mainPart = wordDoc.MainDocumentPart;
        var body = mainPart.Document.Body;
        var fallback = NormalizeDirectionToken(defaultDirection) ?? "ltr";
        var paragraphs = body?.Descendants<Wp.Paragraph>().Take(200).ToList();
        if (paragraphs == null || paragraphs.Count == 0)
        {
            return fallback;
        }

        int rtlCount = 0;
        int ltrCount = 0;

        foreach (var paragraph in paragraphs)
        {
            var plainText = ExtractParagraphPlainText(paragraph);
            if (string.IsNullOrWhiteSpace(plainText))
            {
                continue;
            }

            var resolved = ResolveParagraphDirection(paragraph, mainPart, fallback);
            if (resolved == "rtl") rtlCount++;
            else ltrCount++;
        }

        if (rtlCount == ltrCount)
        {
            return fallback;
        }

        return rtlCount > ltrCount ? "rtl" : "ltr";
    }
    catch
    {
        return NormalizeDirectionToken(defaultDirection) ?? "ltr";
    }
}

private static string ResolveParagraphDirection(Wp.Paragraph paragraph, MainDocumentPart mainPart, string fallbackDirection, bool preferInherit = false)
{
    var fallback = NormalizeDirectionToken(fallbackDirection) ?? "ltr";
    if (paragraph == null) return preferInherit ? "inherit" : fallback;

    if (IsParagraphExplicitlyRtl(paragraph, mainPart)) return "rtl";
    if (IsParagraphExplicitlyLtr(paragraph, mainPart)) return "ltr";

    var inferred = InferDirectionFromParagraphText(paragraph);
    if (!string.IsNullOrEmpty(inferred)) return inferred;

    return preferInherit ? "inherit" : fallback;
}

private static string ResolveTableDirection(Wp.TableProperties tableProperties)
{
    if (tableProperties == null) return "inherit";

    if (IsPropertyEnabled(tableProperties.GetFirstChild<Wp.BiDiVisual>()))
    {
        return "rtl";
    }

    return "inherit";
}

private static double? ConvertTwipsToPixels(double? twips)
{
    if (!twips.HasValue || twips.Value <= 0) return null;
    var pixels = twips.Value * 96.0 / 1440.0;
    return Math.Round(pixels, 2);
}

private static double? ConvertTwipsToPixels(string widthValue)
{
    if (string.IsNullOrWhiteSpace(widthValue)) return null;
    if (double.TryParse(widthValue, NumberStyles.Any, CultureInfo.InvariantCulture, out var twips))
    {
        return ConvertTwipsToPixels((double?)twips);
    }
    return null;
}

private static bool IsParagraphExplicitlyRtl(Wp.Paragraph paragraph, MainDocumentPart mainPart)
{
    var pPr = paragraph?.ParagraphProperties;
    if (pPr == null) return false;

    if (IsPropertyEnabled(pPr.BiDi)) return true;

    var textDirection = pPr.GetFirstChild<Wp.TextDirection>()?.Val?.Value;
    if (IsRtlTextDirection(textDirection)) return true;

    var styleId = pPr.ParagraphStyleId?.Val?.Value;
    return IsStyleChainRtl(styleId, mainPart);
}

private static bool IsParagraphExplicitlyLtr(Wp.Paragraph paragraph, MainDocumentPart mainPart)
{
    var pPr = paragraph?.ParagraphProperties;
    if (pPr == null) return false;

    if (pPr.BiDi != null && !IsPropertyEnabled(pPr.BiDi)) return true;

    var textDirection = pPr.GetFirstChild<Wp.TextDirection>()?.Val?.Value;
    if (IsLtrTextDirection(textDirection)) return true;

    var styleId = pPr.ParagraphStyleId?.Val?.Value;
    if (string.IsNullOrEmpty(styleId)) return false;

    try
    {
        var stylesPart = mainPart.StyleDefinitionsPart;
        var visited = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var currentId = styleId;
        while (!string.IsNullOrEmpty(currentId) && visited.Add(currentId))
        {
            var style = stylesPart?.Styles?.Elements<Wp.Style>().FirstOrDefault(s => s.StyleId == currentId);
            var styleBiDi = style?.StyleParagraphProperties?.BiDi;
            if (styleBiDi != null)
            {
                if (IsPropertyEnabled(styleBiDi)) return false;
                return true;
            }
            var styleTextDir = style?.StyleParagraphProperties?.GetFirstChild<Wp.TextDirection>()?.Val?.Value;
            if (IsLtrTextDirection(styleTextDir)) return true;
            currentId = style?.BasedOn?.Val?.Value;
        }
    }
    catch
    {
    }

    return false;
}

private static string InferDirectionFromParagraphText(Wp.Paragraph paragraph)
{
    var text = ExtractParagraphPlainText(paragraph);
    return InferDirectionFromTextContent(text);
}

private static string ExtractParagraphPlainText(Wp.Paragraph paragraph)
{
    if (paragraph == null) return string.Empty;

    var builder = new StringBuilder();
    foreach (var text in paragraph.Descendants<Wp.Text>())
    {
        if (!string.IsNullOrEmpty(text?.Text))
        {
            builder.Append(text.Text);
        }
    }

    return builder.ToString();
}

private static string InferDirectionFromTextContent(string text)
{
    if (string.IsNullOrWhiteSpace(text)) return null;

    int rtlCount = 0;
    int ltrCount = 0;

    foreach (var ch in text)
    {
        if (IsStrongRtlCharacter(ch))
        {
            rtlCount++;
            continue;
        }

        if (IsStrongLtrCharacter(ch))
        {
            ltrCount++;
        }
    }

    if (rtlCount == 0 && ltrCount == 0) return null;
    if (rtlCount == ltrCount) return null;

    return rtlCount > ltrCount ? "rtl" : "ltr";
}

private static bool IsStrongRtlCharacter(char ch)
{
    var code = (int)ch;
    return (code >= 0x0590 && code <= 0x08FF)
        || (code >= 0xFB1D && code <= 0xFDFF)
        || (code >= 0xFE70 && code <= 0xFEFC);
}

private static bool IsStrongLtrCharacter(char ch)
{
    if (IsStrongRtlCharacter(ch)) return false;

    if (char.IsLetter(ch) || char.IsDigit(ch)) return true;

    var code = (int)ch;

    return (code >= 0x0041 && code <= 0x007A) // Basic Latin letters
        || (code >= 0x00C0 && code <= 0x02AF) // Latin extended blocks
        || (code >= 0x1E00 && code <= 0x1EFF); // Latin extended additional
}

private static bool IsStyleChainRtl(string styleId, MainDocumentPart mainPart)
{
    if (string.IsNullOrEmpty(styleId)) return false;

    try
    {
        var stylesPart = mainPart.StyleDefinitionsPart;
        var visited = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var currentId = styleId;
        while (!string.IsNullOrEmpty(currentId) && visited.Add(currentId))
        {
            var style = stylesPart?.Styles?.Elements<Wp.Style>().FirstOrDefault(s => s.StyleId == currentId);
            if (IsPropertyEnabled(style?.StyleParagraphProperties?.BiDi)) return true;
            var styleTextDir = style?.StyleParagraphProperties?.GetFirstChild<Wp.TextDirection>()?.Val?.Value;
            if (IsRtlTextDirection(styleTextDir)) return true;
            currentId = style?.BasedOn?.Val?.Value;
        }
    }
    catch
    {
    }

    return false;
}

private static bool IsLtrTextDirection(Wp.TextDirectionValues? textDirection)
{
    if (!textDirection.HasValue) return false;

    var directionValue = textDirection.Value.ToString();
    switch (directionValue)
    {
        case "LeftToRightTopToBottom":
        case "TopToBottomLeftToRight":
        case "LeftToRight":
        case "LrTb":
        case "TbLr":
        case "Lr":
            return true;
        default:
            return false;
    }
}

private static bool IsRtlTextDirection(Wp.TextDirectionValues? textDirection)
{
    if (!textDirection.HasValue) return false;

    var directionValue = textDirection.Value.ToString();
    switch (directionValue)
    {
        case "RightToLeftTopToBottom":
        case "TopToBottomRightToLeft":
        case "RightToLeft":
        case "TbRl":
        case "Rl":
            return true;
        default:
            return false;
    }
}

private static string GetParagraphAlignment(Wp.Paragraph para, MainDocumentPart mainPart)
{
    var pPr = para.ParagraphProperties;

    if (pPr?.Justification?.Val != null)
    {
        var alignment = pPr.Justification.Val.Value;
        if (alignment == Wp.JustificationValues.Left)
            return "left";
        if (alignment == Wp.JustificationValues.Right)
            return "right";
        if (alignment == Wp.JustificationValues.Center)
            return "center";
        if (alignment == Wp.JustificationValues.Both || alignment == Wp.JustificationValues.Distribute)
            return "justify";
        if (alignment == Wp.JustificationValues.Start)
            return IsPropertyEnabled(pPr.BiDi) ? "right" : "left";
        if (alignment == Wp.JustificationValues.End)
            return IsPropertyEnabled(pPr.BiDi) ? "left" : "right";
        return alignment.ToString().ToLower();
    }

    var styleId = pPr?.ParagraphStyleId?.Val?.Value;
    if (styleId != null)
    {
        var stylesPart = mainPart.StyleDefinitionsPart;
        if (stylesPart != null)
        {
            var style = stylesPart.Styles.Elements<Wp.Style>().FirstOrDefault(s => s.StyleId == styleId);
            if (style != null)
            {
                var styleJustification = style.StyleParagraphProperties?.Justification?.Val;
                if (styleJustification != null)
                {
                    var alignment = styleJustification.Value;
                    var styleBiDi = style.StyleParagraphProperties?.BiDi;
                    var isRtl = IsPropertyEnabled(styleBiDi) || IsPropertyEnabled(pPr?.BiDi);
                    
                    if (alignment == Wp.JustificationValues.Left)
                        return "left";
                    if (alignment == Wp.JustificationValues.Right)
                        return "right";
                    if (alignment == Wp.JustificationValues.Center)
                        return "center";
                    if (alignment == Wp.JustificationValues.Both || alignment == Wp.JustificationValues.Distribute)
                        return "justify";
                    if (alignment == Wp.JustificationValues.Start)
                        return isRtl ? "right" : "left";
                    if (alignment == Wp.JustificationValues.End)
                        return isRtl ? "left" : "right";
                    return alignment.ToString().ToLower();
                }
                
                var baseStyleId = style.BasedOn?.Val?.Value;
                if (baseStyleId != null)
                {
                    var baseStyle = stylesPart.Styles.Elements<Wp.Style>().FirstOrDefault(s => s.StyleId == baseStyleId);
                    if (baseStyle?.StyleParagraphProperties?.Justification?.Val != null)
                    {
                        var baseAlignment = baseStyle.StyleParagraphProperties.Justification.Val.Value;
                        var baseBiDi = baseStyle.StyleParagraphProperties?.BiDi;
                        var isRtl = IsPropertyEnabled(baseBiDi) || IsPropertyEnabled(pPr?.BiDi);
                        
                        if (baseAlignment == Wp.JustificationValues.Left)
                            return "left";
                        if (baseAlignment == Wp.JustificationValues.Right)
                            return "right";
                        if (baseAlignment == Wp.JustificationValues.Center)
                            return "center";
                        if (baseAlignment == Wp.JustificationValues.Both || baseAlignment == Wp.JustificationValues.Distribute)
                            return "justify";
                        if (baseAlignment == Wp.JustificationValues.Start)
                            return isRtl ? "right" : "left";
                        if (baseAlignment == Wp.JustificationValues.End)
                            return isRtl ? "left" : "right";
                        return baseAlignment.ToString().ToLower();
                    }
                }
            }
        }
    }

    var documentSettings = mainPart.DocumentSettingsPart?.Settings;
    var isDocumentRtl = IsPropertyEnabled(documentSettings?.GetFirstChild<Wp.BiDi>());
    var isParagraphRtl = IsPropertyEnabled(pPr?.BiDi);
    
    if (isParagraphRtl || isDocumentRtl)
    {
        return "right";
    }

    return "left";
}
private static string ExtractRunTextWithBreaks(Wp.Run run)
{
    if (run == null) return string.Empty;

    var builder = new StringBuilder();
    foreach (var child in run.ChildElements)
    {
        switch (child)
        {
            case Wp.Text text:
                builder.Append(text.Text);
                break;
            case Wp.TabChar _:
                builder.Append('\t');
                break;
            case Wp.Break _:
            case Wp.CarriageReturn _:
                builder.Append('\n');
                break;
            case Wp.SymbolChar symbol:
                var value = symbol.Char?.Value;
                if (!string.IsNullOrEmpty(value))
                {
                    if (int.TryParse(value, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out int codePoint))
                    {
                        builder.Append(char.ConvertFromUtf32(codePoint));
                    }
                    else
                    {
                        builder.Append(value);
                    }
                }
                break;
            default:
                var inner = child.InnerText;
                if (!string.IsNullOrEmpty(inner))
                {
                    builder.Append(inner);
                }
                break;
        }
    }

    if (builder.Length > 0)
    {
        return builder.ToString();
    }

    return run.InnerText ?? string.Empty;
}

private static JsonParagraph ParseParagraph(Wp.Paragraph para, int elementId, MainDocumentPart mainPart, string structureKey, string fallbackDirection)
{
    var jsonPara = new JsonParagraph { ID = elementId, StructureKey = structureKey };
    var pPr = para.ParagraphProperties;
    if (pPr != null)
    {
        // ... (Formatting logic remains the same)
        var alignment = NormalizeAlignmentToken(GetParagraphAlignment(para, mainPart));
        if (!string.IsNullOrEmpty(alignment))
        {
            jsonPara.Formatting["Alignment"] = alignment;
            jsonPara.Formatting["algin"] = alignment;
        }
        if (pPr.Shading?.Fill != null) jsonPara.Formatting["Shading"] = pPr.Shading.Fill.Value;
        var direction = ResolveParagraphDirection(para, mainPart, fallbackDirection, preferInherit: true);
        if (!string.IsNullOrEmpty(direction)) jsonPara.Formatting["Direction"] = direction;
    }
    var runs = para.Elements<Wp.Run>().ToList();
    for (int i = 0; i < runs.Count; i++)
    {
        var run = runs[i];
        var sdtRun = run.Descendants<Wp.SdtRun>().FirstOrDefault();
        
        // This part handles formal checkbox content controls
        if (sdtRun?.SdtProperties?.GetFirstChild<Wp.CheckBox>() != null)
        {
            var checkedState = sdtRun.SdtProperties.GetFirstChild<Wp.CheckBox>().GetFirstChild<Wp.Checked>();
            string labelText = sdtRun.GetFirstChild<Wp.SdtContentRun>()?.InnerText.Trim() ?? "";
            if (string.IsNullOrWhiteSpace(labelText) && (i + 1) < runs.Count)
            {
                var nextRun = runs[i + 1];
                if (string.IsNullOrEmpty(nextRun.GetFirstChild<Wp.SdtRun>()?.InnerText))
                {
                    labelText = nextRun.InnerText.Trim();
                    if (!string.IsNullOrEmpty(labelText)) { i++; }
                }
            }
            jsonPara.Content.Add(new JsonCheckbox { IsChecked = checkedState?.Val?.Value ?? false, Content = labelText });
        }
        else
        {
            string runText = ExtractRunTextWithBreaks(run);
            if (string.IsNullOrEmpty(runText) && !run.Descendants<Wp.Break>().Any() && !run.Descendants<Wp.CarriageReturn>().Any())
            {
                continue;
            }

            var jsonRun = new JsonRun { Text = runText };
            var rPr = run.RunProperties;
            if (rPr != null)
            {
                if (rPr.Bold != null) jsonRun.Formatting["Bold"] = true;
                if (rPr.Italic != null) jsonRun.Formatting["Italic"] = true;
                if (rPr.Underline != null) { jsonRun.Formatting["Underline"] = true;
                if (rPr.Underline.Val != null) jsonRun.FormattingValues["UnderlineStyle"] = rPr.Underline.Val.Value.ToString(); }
                if (rPr.Color?.Val != null) jsonRun.FormattingValues["ColorValue"] = rPr.Color.Val.Value;
                if (rPr.Highlight?.Val != null) jsonRun.FormattingValues["HighlightValue"] = rPr.Highlight.Val.Value.ToString();
                if (rPr.Shading?.Fill != null) jsonRun.FormattingValues["ShadingValue"] = rPr.Shading.Fill.Value;
                if (rPr.FontSize?.Val != null) jsonRun.FormattingValues["FontSize"] = rPr.FontSize.Val.Value;
                if (rPr.RunFonts?.Ascii != null) jsonRun.FormattingValues["FontFamily"] = rPr.RunFonts.Ascii.Value;
            }
            jsonPara.Content.Add(jsonRun);
        }
    }
    if (para.Descendants<Wp.Drawing>().Any())
    {
        var images = ParseImages(para, elementId, mainPart, structureKey);
        if (images != null) { jsonPara.Content.AddRange(images); }
    }
    return jsonPara;
}

    private static JsonTable ParseTable(Wp.Table table, int elementId, MainDocumentPart mainPart, string structureKey, string fallbackDirection)
    {
        var jsonTable = new JsonTable { ID = elementId, StructureKey = structureKey };
        var tblProps = table.GetFirstChild<Wp.TableProperties>();
        var normalizedFallback = NormalizeDirectionToken(fallbackDirection) ?? "ltr";
        var isDocumentRtl = normalizedFallback == "rtl";
        var tableDirection = ResolveTableDirection(tblProps);
        var tableIsRtl = tableDirection == "rtl" || (tableDirection == "inherit" && isDocumentRtl);
        if (tblProps != null)
        {
            var borders = tblProps.GetFirstChild<Wp.TableBorders>();
            if (borders != null)
            {
                jsonTable.Borders["Top"] = GetBorderStyle(borders.TopBorder) ?? "inherit";
                jsonTable.Borders["Bottom"] = GetBorderStyle(borders.BottomBorder) ?? "inherit";
                jsonTable.Borders["Left"] = GetBorderStyle(borders.LeftBorder) ?? "inherit";
                jsonTable.Borders["Right"] = GetBorderStyle(borders.RightBorder) ?? "inherit";
                jsonTable.Borders["InsideH"] = GetBorderStyle(borders.InsideHorizontalBorder) ?? "inherit";
                jsonTable.Borders["InsideV"] = GetBorderStyle(borders.InsideVerticalBorder) ?? "inherit";
            }
        }
        var columnWidths = new List<double?>();
        var tableGrid = table.GetFirstChild<Wp.TableGrid>();
        if (tableGrid != null)
        {
            foreach (var gridColumn in tableGrid.Elements<Wp.GridColumn>())
            {
                double? pxWidth = null;
                if (gridColumn.Width != null)
                {
                    double? widthTwips = gridColumn.Width.Value;
                    pxWidth = ConvertTwipsToPixels(widthTwips);
                }
                else
                {
                    var rawWidth = gridColumn.GetAttribute("w", "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
                    pxWidth = ConvertTwipsToPixels(rawWidth?.Value);
                }
                columnWidths.Add(pxWidth);
            }
        }
        jsonTable.ColumnWidths = columnWidths;

        var tableData = new List<JsonTableRow>();
        int rowIndex = 0;
        foreach (var row in table.Elements<Wp.TableRow>())
        {
            var jsonRow = new JsonTableRow();
            int cellIndex = 0;
            foreach (var cell in row.Elements<Wp.TableCell>())
            {
                var jsonCell = new JsonTableCell();
                var firstPara = cell.Elements<Wp.Paragraph>().FirstOrDefault();
                if (firstPara != null)
                {
                    jsonCell.Direction = ResolveParagraphDirection(firstPara, mainPart, normalizedFallback, preferInherit: true);
                    if (jsonCell.Direction == "inherit" && tableDirection != "inherit")
                    {
                        jsonCell.Direction = tableDirection;
                    }
                    jsonCell.Alignment = NormalizeAlignmentToken(GetParagraphAlignment(firstPara, mainPart));
                }
                else
                {
                    jsonCell.Direction = tableDirection == "inherit" ? "inherit" : tableDirection;
                    jsonCell.Alignment = null;
                }

                var paragraphs = cell.Elements<Wp.Paragraph>().ToList();
                for (int paragraphIndex = 0; paragraphIndex < paragraphs.Count; paragraphIndex++)
                {
                    var para = paragraphs[paragraphIndex];
                    string paragraphKey = string.IsNullOrEmpty(structureKey)
                        ? null
                        : $"{structureKey}.r{rowIndex}c{cellIndex}p{paragraphIndex}";
                    var parsedPara = ParseParagraph(para, 0, mainPart, paragraphKey, fallbackDirection);
                    if (parsedPara?.Content != null)
                    {
                        var runs = parsedPara.Content.OfType<JsonRun>();
                        if (runs != null) jsonCell.FormattedRuns.AddRange(runs);
                        var checkboxes = parsedPara.Content.OfType<JsonCheckbox>();
                        if (checkboxes != null) jsonCell.Checkboxes.AddRange(checkboxes);
                    }
                    if (paragraphIndex < paragraphs.Count - 1 && jsonCell.FormattedRuns.Count > 0)
                    {
                        jsonCell.FormattedRuns.Add(new JsonRun { Text = "\n" });
                    }
                }
                jsonCell.Content = string.Join("", jsonCell.FormattedRuns.Where(r => r != null).Select(r => r.Text ?? ""));
                var cellProps = cell.TableCellProperties;
                if (cellProps != null)
                {
                    if (cellProps.GridSpan?.Val != null) jsonCell.GridSpan = cellProps.GridSpan.Val.Value;
                    if (cellProps.VerticalMerge != null) jsonCell.VerticalMerge = cellProps.VerticalMerge.Val?.Value == Wp.MergedCellValues.Restart ? "Restart" : "Continue";
                    if (cellProps.TextDirection != null && cellProps.TextDirection.Val != null)
                    {
                        jsonCell.TextRotation = cellProps.TextDirection.Val.Value.ToString();
                    }

                    var cellBorders = cellProps.TableCellBorders;
                    jsonCell.Borders["Top"] = GetBorderStyle(cellBorders?.TopBorder) ?? "inherit";
                    jsonCell.Borders["Bottom"] = GetBorderStyle(cellBorders?.BottomBorder) ?? "inherit";
                    jsonCell.Borders["Left"] = GetBorderStyle(cellBorders?.LeftBorder) ?? "inherit";
                    jsonCell.Borders["Right"] = GetBorderStyle(cellBorders?.RightBorder) ?? "inherit";
                    jsonCell.Borders["Background"] = cellProps.Shading?.Fill ?? "inherit";
                }
                jsonRow.Cells.Add(jsonCell);
                cellIndex++;
            }
            tableData.Add(jsonRow);
            rowIndex++;
        }
        int rtlCellCount = 0;
        int ltrCellCount = 0;
        foreach (var row in tableData)
        {
            foreach (var cell in row.Cells)
            {
                var normalizedCellDirection = NormalizeDirectionToken(cell.Direction);
                if (string.IsNullOrEmpty(normalizedCellDirection) || normalizedCellDirection == "inherit")
                {
                    normalizedCellDirection = tableIsRtl ? "rtl" : "ltr";
                }
                if (normalizedCellDirection == "rtl")
                {
                    rtlCellCount++;
                }
                else if (normalizedCellDirection == "ltr")
                {
                    ltrCellCount++;
                }
            }
        }

        string finalTableDirection;
        if (rtlCellCount > ltrCellCount)
        {
            finalTableDirection = "rtl";
        }
        else if (ltrCellCount > rtlCellCount)
        {
            finalTableDirection = "ltr";
        }
        else if (tableDirection == "rtl" || tableDirection == "ltr")
        {
            finalTableDirection = tableDirection;
        }
        else if (tableDirection == "inherit")
        {
            finalTableDirection = normalizedFallback;
        }
        else
        {
            finalTableDirection = normalizedFallback;
        }

        var effectiveTableDirection = NormalizeDirectionToken(finalTableDirection) ?? "ltr";
        var defaultAlignment = NormalizeAlignmentToken(effectiveTableDirection == "rtl" ? "right" : "left");

        foreach (var row in tableData)
        {
            foreach (var cell in row.Cells)
            {
                var normalizedCellDirection = NormalizeDirectionToken(cell.Direction);
                if (string.IsNullOrEmpty(normalizedCellDirection) || normalizedCellDirection == "inherit")
                {
                    cell.Direction = effectiveTableDirection;
                }

                if (string.IsNullOrEmpty(cell.Alignment))
                {
                    cell.Alignment = defaultAlignment;
                }
            }
        }

        jsonTable.Borders["Direction"] = effectiveTableDirection;
        jsonTable.Content = tableData;
        CalculateRowSpans(jsonTable);
        return jsonTable;
    }

    private static void CalculateRowSpans(JsonTable jsonTable)
    {
        for (int rowIndex = 0; rowIndex < jsonTable.Content.Count; rowIndex++)
        {
            var row = jsonTable.Content[rowIndex];
            for (int colIndex = 0; colIndex < row.Cells.Count; colIndex++)
            {
                var cell = row.Cells[colIndex];
                if (cell.VerticalMerge == "Restart")
                {
                    int rowspan = 1;
                    for (int nextRow = rowIndex + 1; nextRow < jsonTable.Content.Count; nextRow++)
                    {
                        if (colIndex < jsonTable.Content[nextRow].Cells.Count && jsonTable.Content[nextRow].Cells[colIndex].VerticalMerge == "Continue") { rowspan++; } else { break; }
                    }
                    cell.rowSpan = rowspan;
                }
            }
        }
    }



    private static string GetBorderStyle(OpenXmlElement border)
    {
        try
        {
            if (border == null) return null;

            var valAttribute = border.GetAttributes().FirstOrDefault(a => a.LocalName == "val");
            if (valAttribute != null && valAttribute.Value != "none" && valAttribute.Value != "nil")
            {
                return valAttribute.Value;
            }

            return null;
        }
        catch
        {
            return null;
        }
    }

    private static List<JsonImage> ParseImages(OpenXmlElement element, int elementId, MainDocumentPart mainPart, string structureKey)
    {
        var images = new List<JsonImage>();
        try
        {
            var drawings = element.Descendants<Wp.Drawing>();
            int imageIndex = 0;
            foreach (var drawing in drawings)
            {
                var blip = drawing.Descendants<A.Blip>().FirstOrDefault();
                if (blip?.Embed?.Value != null)
                {
                    var imagePart = mainPart.GetPartById(blip.Embed.Value);
                    if (imagePart != null)
                    {
                        using (var stream = imagePart.GetStream())
                        {
                            var imageBytes = new byte[stream.Length];
                            stream.Read(imageBytes, 0, imageBytes.Length);
                            string base64String = Convert.ToBase64String(imageBytes);
                            string imageKey = string.IsNullOrEmpty(structureKey) ? null : $"{structureKey}:img{imageIndex}";
                            images.Add(new JsonImage { ID = elementId, Content = base64String, StructureKey = imageKey });
                        }
                    }
                }
                imageIndex++;
            }
        }
        catch
        {
        }
        return images;
    }

    private static void AddFooter(Wp.Body body, string recordID)
    {
        DataTable dtRecord = DBHelper.gettabel("select Document_number, Document_date, Email, begin_date from DC_Documents_records_single_id('" + recordID.Replace("'", "''") + "')");
        if (dtRecord.Rows.Count > 0)
        {
            string documentNumber = dtRecord.Rows[0]["Document_number"].ToString();
            DateTime createdTime = Convert.ToDateTime(dtRecord.Rows[0]["begin_date"]);
            string userCreated = dtRecord.Rows[0]["Email"].ToString();
            string userPrinted = DBHelper.UserEmail("");
            DateTime printTime = DateTime.Now;
            body.Append(new Wp.Paragraph());
            body.Append(CreateFooterTable(documentNumber, createdTime, userCreated, userPrinted, printTime));
        }
    }

    private static Wp.Table CreateFooterTable(string docNum, DateTime createdTime, string userCreated, string userPrinted, DateTime printTime)
    {
        Wp.Table table = new Wp.Table();
        Wp.TableProperties props = new Wp.TableProperties(
            new Wp.TableWidth() { Width = "5000", Type = Wp.TableWidthUnitValues.Pct },
            new Wp.TableBorders(new Wp.TopBorder { Val = new EnumValue<Wp.BorderValues>(Wp.BorderValues.None) }, new Wp.BottomBorder { Val = new EnumValue<Wp.BorderValues>(Wp.BorderValues.None) }, new Wp.LeftBorder { Val = new EnumValue<Wp.BorderValues>(Wp.BorderValues.None) }, new Wp.RightBorder { Val = new EnumValue<Wp.BorderValues>(Wp.BorderValues.None) }, new Wp.InsideHorizontalBorder { Val = new EnumValue<Wp.BorderValues>(Wp.BorderValues.None) }, new Wp.InsideVerticalBorder { Val = new EnumValue<Wp.BorderValues>(Wp.BorderValues.None) })
        );
        table.AppendChild(props);
        Wp.TableRow row = new Wp.TableRow();
        row.Append(CreateTableCell($"Doc Num:({docNum})"), CreateTableCell($"Created: {createdTime:yyyy-MM-dd hh:mm tt}"), CreateTableCell($"By: {userCreated}"), CreateTableCell($"Printed By: {userPrinted}"), CreateTableCell($"Print Time: {printTime:yyyy-MM-dd hh:mm tt}"));
        table.Append(row);
        return table;
    }

    private static Wp.TableCell CreateTableCell(string text)
    {
        return new Wp.TableCell(new Wp.Paragraph(new Wp.Run(new Wp.Text(text) { Space = SpaceProcessingModeValues.Preserve })));
    }

    public static byte[] ConvertDocxToPdf(byte[] docxBytes)
    {
        if (docxBytes == null || docxBytes.Length == 0) throw new ArgumentException("Input byte array is null or empty.");
        using (MemoryStream docxStream = new MemoryStream(docxBytes))
        {
            var document = new Document(docxStream, FileFormat.Docx);
            using (MemoryStream pdfStream = new MemoryStream())
            {
                document.SaveToStream(pdfStream, FileFormat.PDF);
                return pdfStream.ToArray();
            }
        }
    }

    public static byte[] ConvertDocxToHtml(byte[] docxBytes)
    {
        if (docxBytes == null || docxBytes.Length == 0) throw new ArgumentException("Input byte array is null or empty.");
        using (MemoryStream docxStream = new MemoryStream(docxBytes))
        {
            var document = new Document(docxStream, FileFormat.Docx);
            document.HtmlExportOptions.ImageEmbedded = true;
            document.HtmlExportOptions.CssStyleSheetType = Spire.Doc.CssStyleSheetType.Inline;
            using (MemoryStream htmlStream = new MemoryStream())
            {
                document.SaveToStream(htmlStream, FileFormat.Html);
                return htmlStream.ToArray();
            }
        }
    }
    public static int ExtractVersionNumber(string filePath)
{
    var fileName = Path.GetFileNameWithoutExtension(filePath);
    var match = VersionPattern.Match(fileName);
    if (match.Success && match.Groups[2].Success && int.TryParse(match.Groups[2].Value, out int version))
    {
        return version;
    }
    return 0; // Default to version 0 if not found
}
}


    public string GetPar(string key, HttpRequestBase request) => Mas.com.eg.Models.invoice.GetPar(key, request);
}
@{
    string id = ViewBag.id;
    string dataResult = "";
    string contentType = "application/json; charset=utf-8";
    byte[] fileBytes = null;
    string filename = "document";
    Layout = null;
    string appPath = HttpRuntime.AppDomainAppPath;

    try
    {
        if (id == "read")
        {
            string relativePath = GetPar("filePath", Request);
            if (string.IsNullOrEmpty(relativePath))
            {
                throw new ArgumentException("filePath parameter is missing or empty.");
            }

            int? version = null;
            string versionParam = GetPar("v", Request);
            if (!string.IsNullOrEmpty(versionParam) && int.TryParse(versionParam, out int v))
            {
                version = v;
            }

            string fullPath = Path.Combine(appPath, relativePath.TrimStart('\\', '/').Replace('/', '\\'));
            var result = DocumentConverter.ConvertDocxToJson(fullPath, version);
            dataResult = JsonConvert.SerializeObject(result);
        }
        else if (id == "write" || id == "pdf" || id == "html")
        {
            string jsonInput = GetPar("jsonInput", Request);
            string recordID = GetPar("recordid", Request);

            if (string.IsNullOrEmpty(jsonInput))
            {
                throw new ArgumentException("jsonInput parameter is missing or empty.");
            }

            DocumentConverter.NewDoc result = DocumentConverter.ConvertJsonToDocx(jsonInput, appPath, recordID);
            if (!result.success)
            {
                dataResult = JsonConvert.SerializeObject(result);
            }
            else
            {
                fileBytes = result.fileBytes;
                var tempPayload = JsonConvert.DeserializeObject<DocumentConverter.JsonPayload>(jsonInput);
                if (tempPayload != null && !string.IsNullOrEmpty(tempPayload.FileVersionPath))
                {
                    filename = Path.GetFileNameWithoutExtension(tempPayload.FileVersionPath);
                }

                if (id == "write")
                {
                    contentType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
                }
                else if (id == "pdf")
                {
                    fileBytes = DocumentConverter.ConvertDocxToPdf(fileBytes);
                    contentType = "application/pdf";
                }
                else if (id == "html")
                {
                    try
                    {
                        fileBytes = DocumentConverter.ConvertDocxToHtml(fileBytes);
                        contentType = "text/html";
                    }
                    catch (Exception ex)
                    {
                        fileBytes = null;
                        dataResult = JsonConvert.SerializeObject(new { success = false, message = "Error during HTML conversion: " + ex.Message });
                    }
                }
            }
        }
        else if (id == "upload_new_file")
{
    string relativePath = GetPar("p", Request);
    string baseFilePath = GetPar("baseFilePath", Request); // Get the new parameter for versioning existing files

    if (Request.Files.Count == 0)
    {
        dataResult = JsonConvert.SerializeObject(new { success = false, message = "No file was uploaded." });
    }
    else
    {
        HttpPostedFileBase uploadedFile = Request.Files[0];
        string finalSavePath = "";
        bool canSave = true;

        // Case 1: This is a new version of an EXISTING document.
        // The 'uploadTemplateButton' was clicked.
        if (!string.IsNullOrEmpty(baseFilePath))
        {
            string fullBasePath = Path.Combine(appPath, baseFilePath.TrimStart('\\', '/').Replace('/', '\\'));
            // Generate the next version name based on the path of the file we are updating.
            finalSavePath = DocumentConverter.GenerateNewVersionFileName(fullBasePath);
        }
        // Case 2: This is a brand new document upload.
        // The 'addNewFileModal' was used.
        else
        {
            string uploadedFileName = Path.GetFileName(uploadedFile.FileName);
            string saveDir = Path.Combine(appPath, relativePath, "Forms");
            if (!Directory.Exists(saveDir)) { Directory.CreateDirectory(saveDir); }
            
            string initialPath = Path.Combine(saveDir, uploadedFileName);
            var match = DocumentConverter.VersionPattern.Match(Path.GetFileNameWithoutExtension(uploadedFileName));

            // Sub-case 2a: The new file is uploaded with a specific revision number.
            if (match.Success && match.Groups[2].Success)
            {
                if (System.IO.File.Exists(initialPath))
                {
                    canSave = false;
                    dataResult = JsonConvert.SerializeObject(new { success = false, message = $"File with the same name '{uploadedFileName}' already exists. Replacement is not allowed." });
                }
                else
                {
                    finalSavePath = initialPath;
                }
            }
            // Sub-case 2b: The new file has no revision number, so we assign one.
            else
            {
                finalSavePath = DocumentConverter.GenerateNewVersionFileName(initialPath);
            }
        }

        if (canSave)
        {
            uploadedFile.SaveAs(finalSavePath);
            int finalVersion = DocumentConverter.ExtractVersionNumber(finalSavePath);
            dataResult = JsonConvert.SerializeObject(new
            {
                success = true,
                message = $"File uploaded successfully. Version is now (Rev {finalVersion:D2}).",
                filePath = finalSavePath.Replace(appPath, "")
            });
        }
    }
}else if (id == "upload_coded_file")
        {
            string relativePath = GetPar("p", Request); // e.g., "Docs/1 - Laboratory"
            string codedFileName = GetPar("codedFileName", Request);

            if (Request.Files.Count == 0)
            {
                dataResult = JsonConvert.SerializeObject(new { success = false, message = "    ." });
            }
            else if (string.IsNullOrEmpty(codedFileName))
            {
                dataResult = JsonConvert.SerializeObject(new { success = false, message = "   ." });
            }
            else
            {
                HttpPostedFileBase uploadedFile = Request.Files[0];
                // The target directory is always the 'Forms' subfolder within the current department path
string saveDir = Path.Combine(appPath, "Docs", relativePath, "Forms");
                if (!Directory.Exists(saveDir))
                {
                    Directory.CreateDirectory(saveDir);
                }

                string finalSavePath = Path.Combine(saveDir, codedFileName);

                // Check if a file with the same name already exists to prevent overwriting
                if (System.IO.File.Exists(finalSavePath))
                {
                    dataResult = JsonConvert.SerializeObject(new { success = false, message = $"   '{codedFileName}'  .       ." });
                }
                else
                {
                    uploadedFile.SaveAs(finalSavePath);
                    dataResult = JsonConvert.SerializeObject(new { success = true, message = "    .", filePath = finalSavePath.Replace(appPath, "") });
                }
            }
        }
        else if (id == "fullObject")
        {
            string filePath = GetPar("filePath", Request);
            if (string.IsNullOrEmpty(filePath))
            {
                throw new ArgumentException("filePath parameter is missing or empty");
            }
            string fullPath = Path.Combine(appPath, filePath.Replace('/', '\\'));
            string latestVersionPath = DocumentConverter.GetVersionedPath(fullPath, null);

            if (!System.IO.File.Exists(latestVersionPath))
            {
                dataResult = JsonConvert.SerializeObject(new { success = false, message = "    ." });
            }
            else
            {
                using (WordprocessingDocument wordDoc = WordprocessingDocument.Open(latestVersionPath, false))
                {
                    var body = wordDoc.MainDocumentPart.Document.Body;
                    Newtonsoft.Json.Linq.JObject fullJson = ConvertElementToJson(body);
                    dataResult = JsonConvert.SerializeObject(new { success = true, documentTree = fullJson }, Formatting.Indented);
                }
            }
        }
        else
        {
            dataResult = JsonConvert.SerializeObject(new { success = false, message = "  ." });
        }
    }
    catch (Exception ex)
    {
        Response.StatusCode = 500;
        dataResult = JsonConvert.SerializeObject(new { success = false, message = ex.Message, stackTrace = ex.StackTrace });
    }

    if (fileBytes != null && fileBytes.Length > 0)
    {
        string extension = ".tmp";
        if (contentType.Contains("pdf")) { extension = ".pdf"; }
        else if (contentType.Contains("html")) { extension = ".html"; }
        else if (contentType.Contains("wordprocessingml")) { extension = ".docx"; }

        if (contentType != "text/html")
        {
            Response.AddHeader("Content-Disposition", $"attachment; filename=\"{filename}{extension}\"");
        }
        Response.ContentType = contentType;
        Response.BinaryWrite(fileBytes);
    }
    else
    {
        Response.ContentType = "application/json; charset=utf-8";
        Response.Write(dataResult);
    }

    Response.Flush();
    Response.End();
}


}
